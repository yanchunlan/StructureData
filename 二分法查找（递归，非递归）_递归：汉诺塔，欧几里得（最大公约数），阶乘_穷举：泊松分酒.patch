Index: app/src/main/java/com/example/ycl/structuredata/structure_data/algo/recursion/CalNFact.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/ycl/structuredata/structure_data/algo/recursion/CalNFact.java	(date 1532506610152)
+++ app/src/main/java/com/example/ycl/structuredata/structure_data/algo/recursion/CalNFact.java	(date 1532506610152)
@@ -0,0 +1,20 @@
+package com.example.ycl.structuredata.structure_data.algo.recursion;
+
+/**
+ * @Author: Ycl
+ * @Date: 2018/7/25 16:10
+ * @Desc: 求阶乘 n! (递归的思想)
+ */
+public class CalNFact {
+    public long f(long n) {
+        if (n == 1) {
+            return n;
+        } else {
+            return n * f(n - 1);
+        }
+    }
+
+    public void test() {
+        System.out.println("5! : " + f(20));
+    }
+}
Index: app/src/main/java/com/example/ycl/structuredata/structure_data/algo/recursion/Gcd.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/ycl/structuredata/structure_data/algo/recursion/Gcd.java	(date 1532504877400)
+++ app/src/main/java/com/example/ycl/structuredata/structure_data/algo/recursion/Gcd.java	(date 1532504877400)
@@ -0,0 +1,24 @@
+package com.example.ycl.structuredata.structure_data.algo.recursion;
+
+/**
+ * @Author: Ycl
+ * @Date: 2018/7/25 15:32
+ * @Desc: 欧几里得-找到最大公约数
+ */
+public class Gcd {
+    // (m>n)  m和n的最大公约数 = n 和m%n的最大公约数
+    //  36 24  12 = 24  36%24=12       =  12 和 0
+
+    public int gcd(int m, int n) {
+        if (n == 0) {
+            return m;
+        } else {
+            return gcd(n, m % n);
+        }
+    }
+
+    public void test() {
+        System.out.println("gcd: " + gcd(36, 24));
+        System.out.println("gcd: " + gcd(99, 55));
+    }
+}
Index: app/src/main/java/com/example/ycl/structuredata/structure_data/algo/recursion/HanNoTa.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/ycl/structuredata/structure_data/algo/recursion/HanNoTa.java	(date 1532503922453)
+++ app/src/main/java/com/example/ycl/structuredata/structure_data/algo/recursion/HanNoTa.java	(date 1532503922453)
@@ -0,0 +1,28 @@
+package com.example.ycl.structuredata.structure_data.algo.recursion;
+
+/**
+ * @Author: Ycl
+ * @Date: 2018/7/25 14:38
+ * @Desc: 汉诺塔-迭代
+ */
+public class HanNoTa {
+    private int i = 1;// 移动计数
+    public void hanNota(int n, char from, char dependOn, char to) {
+        if (n == 1) {
+            move(1, from, to);
+        } else {
+            // 根据3个盘子，2个盘子得出规律
+            hanNota(n - 1, from, to, dependOn);//第一步，先将n-1个盘子从A利用C挪到B
+            move(n, from, to);//讲n这个盘子（底盘）从A挪到C
+            hanNota(n - 1, dependOn, from, to);//讲n-1个盘子从B利用A挪到C
+        }
+    }
+
+    private void move(int n, char from, char to) {
+        System.out.println("第" + i++ + "步从" + from + "------>" + to);
+    }
+
+    public void test() {
+        hanNota(100, 'A', 'B', 'C');
+    }
+}
Index: app/src/main/java/com/example/ycl/structuredata/structure_data/algo/search/BinarySearch.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/ycl/structuredata/structure_data/algo/search/BinarySearch.java	(revision 2543d8278fff55d29fa54534c285a922e4ea8093)
+++ app/src/main/java/com/example/ycl/structuredata/structure_data/algo/search/BinarySearch.java	(date 1532486443688)
@@ -1,5 +1,8 @@
 package com.example.ycl.structuredata.structure_data.algo.search;
 
+import com.example.ycl.structuredata.structure_data.algo.sort.BasicSort;
+import com.example.ycl.structuredata.structure_data.algo.sort.Sort;
+
 /**
  * author: ycl
  * date: 2018-07-25 0:40
@@ -7,5 +10,63 @@
  */
 public class BinarySearch {
 
+    /**
+     * 递归的方式
+     */
+    public static int binarySearch(int elem, int[] array, int low, int high) {
+        if (low > high) {
+            return -1;
+        }
+        int middle = (low + high) / 2;
+        if (array[middle] == elem) {// 找到了
+            System.out.println();
+            System.out.println("找到对应元素值，下标为：" + middle);
+            return elem;
+        }
+        if (array[middle] < elem) {// 找右边
+            return binarySearch(elem, array, middle + 1, high);
+        }
+        if (array[middle] > elem) {// 找左边
+            return binarySearch(elem, array, low, middle - 1);
+        }
+        return -1;
+    }
+
+    /**
+     * 非递归
+     */
+    public static int directbinarysearch(int[] array, int elem) {
+        int low = 0;
+        int high = array.length - 1;
+        while (low <= high) {
+            int middle = (low + high) / 2;
+            if (elem > array[middle]) {
+                low = middle + 1;
+            } else if (elem < array[middle]) {
+                high = middle - 1;
+            } else {
+                System.out.println("找到相应元素，下标为：" + middle);
+                return middle;
+            }
+        }
+        return -1;
+    }
+
+
+    public static void test() {
+        int[] array = {10, 23, 4, 3, 2, 5, 1, 2, 623, 92, 23, 23, 234, 2, 34, 234, 234, 2, 10};
+
+        // 奇数排序
+        Sort.printSort(array, "交换之前：");
+        new BasicSort().basicSort(array);
+        Sort.printSort(array, "交换后：");
 
+        // 查找5的位置
+//       int ret=
+        binarySearch(5, array, 0, array.length - 1);
+        directbinarysearch(array, 4);
+//        System.out.println(""+ret);
+
+
+    }
 }
Index: app/src/main/java/com/example/ycl/structuredata/structure_data/algo/sharewine/ShareWine.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/ycl/structuredata/structure_data/algo/sharewine/ShareWine.java	(date 1532511040563)
+++ app/src/main/java/com/example/ycl/structuredata/structure_data/algo/sharewine/ShareWine.java	(date 1532511040563)
@@ -0,0 +1,51 @@
+package com.example.ycl.structuredata.structure_data.algo.sharewine;
+
+/**
+ * @Author: Ycl
+ * @Date: 2018/7/25 16:17
+ * @Desc: 穷举-泊松分酒
+ */
+public class ShareWine {
+    private int b1 = 12;
+    private int b2 = 8;
+    private int b3 = 5;
+    private int m = 5;// 目标酒量
+
+    // 假设一开始12,0,0
+    private void backBottle(int bb1, int bb2, int bb3) {
+        System.out.println("bb1:" + bb1 + "     bb2:" + bb2 + "     bb3:" + bb3);
+        if (bb1 == m || bb2 == m || bb3 == m) {
+            System.out.println("find the bottle"); // 分配成功
+            return;
+        }
+        if (bb2 != 0 && bb3 != b3) {
+            // b2倒满b3
+            if (bb2 + bb3 <= b3) {
+                // 倒不满
+                backBottle(bb1, 0, bb2 + bb3);
+            } else {// 能够满
+                backBottle(bb1, bb2 - (b3 - bb3), b3);
+            }
+        } else if (bb3 == b3) {
+            // b3满了，往b1倒
+            if (bb3 + bb1 <= b1) {
+                // 说明倒完后b1没满
+                backBottle(bb1 + bb3, bb2, 0);
+            } else {
+                backBottle(b1, bb2, bb3 - (b1 - bb1));
+            }
+        } else if (bb2 == 0) {
+            // 取b1倒水到b2
+            if (bb1 >= bb2) {
+                backBottle(bb1 - b2, b2, bb3);
+            } else {
+                backBottle(0, bb1 + bb2, bb3);
+            }
+        }
+    }
+
+
+    public void test() {
+        backBottle(12, 0, 0);
+    }
+}
Index: app/src/main/java/com/example/ycl/structuredata/structure_data/graph/DnJavaDijstra.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/ycl/structuredata/structure_data/graph/DnJavaDijstra.java	(revision 2543d8278fff55d29fa54534c285a922e4ea8093)
+++ app/src/main/java/com/example/ycl/structuredata/structure_data/graph/DnJavaDijstra.java	(date 1532484752282)
@@ -3,7 +3,7 @@
 /**
  * @Author: Ycl
  * @Date: 2018/7/19 16:33
- * @Desc: 图-最短路径
+ * @Desc: 图-最短路径-迪杰斯塔拉
  */
 public class DnJavaDijstra {
     private static final int MAXVEX = 9;
Index: app/src/main/java/com/example/ycl/structuredata/structure_data/TestList.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/ycl/structuredata/structure_data/TestList.java	(revision 2543d8278fff55d29fa54534c285a922e4ea8093)
+++ app/src/main/java/com/example/ycl/structuredata/structure_data/TestList.java	(date 1532510802670)
@@ -1,6 +1,6 @@
 package com.example.ycl.structuredata.structure_data;
 
-import com.example.ycl.structuredata.structure_data.algo.sort.BasicSort;
+import com.example.ycl.structuredata.structure_data.algo.sharewine.ShareWine;
 
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -66,7 +66,19 @@
 //        Sort.test();
 //        new QuickSort().test();
 //        new MergeSort().test();
-        new BasicSort().test();
+//        new BasicSor().test();
+//        BinarySearch.test();
+
+
+        // 递归: 自己调用自己 ； 迭代：调用别人
+//        new HanNoTa().test(); // 汉诺塔
+//        new Gcd().test(); // 欧几里得
+//        new CalNFact().test(); // 阶乘
+
+
+        // 穷举：泊松分酒
+        new ShareWine().test(); // 阶乘
+
+
     }
-
 }
Index: resource/笔记.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- resource/笔记.txt	(revision 2543d8278fff55d29fa54534c285a922e4ea8093)
+++ resource/笔记.txt	(date 1532506638583)
@@ -20,4 +20,11 @@
 	图的最短路径、迪杰斯特拉算法
 	拓扑排序
 6.算法
+	排序：选择排序
+		直接插入排序，二分法排序，希尔排序，堆排序
+		快速排序，归并排序，奇数排序
+	查找：二分法查找（递归，非递归）
+	递归：汉诺塔，欧几里得（最大公约数），阶乘
+	穷举：泊松分酒
+		
 	
\ No newline at end of file
